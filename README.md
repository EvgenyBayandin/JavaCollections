# JavaCollections
Типы коллекций их отличия

В Java 3 наиболее часто используемых типа коллекций: списки (list), наборы (set) и словари, карты, справочники (map).

Список (list).

List расширяет интерфейс Collection. Список хранит любые значения, в том числе повторяющиеся.
Итерация (обход) списка происходит в порядке добавления элементов, т.е. элемент, добавленный первым, при итерации также будет первым.
Реализации интерфейса List – ArrayList и LinkedList.

ArrayList построен на базе массива.

Удобен для операций чтения, доступ по индексу (порядковому номеру элемента) происходит очень быстро.
Сложности возникают при добавлении значений в середину листа, интерфейсу приходится копировать и смещать все последующие по индексу значения, а если ячейки заняты, создавать новый лист (увеличенный размер массива), куда копируются имеющиеся значения и добавляется новое.

Особенности: 
- хранит не уникальные элементы;
- вывод значений упорядочен по вводу.


LinkedList.

LinkedList представляет собой цепочку элементов, в которой каждый элемент имеет ссылку на предыдущий элемент и на следующий. Также имеется ссылка на начало и на конец списка, что позволяет быстро получать доступ к первому и к последнему элементу. Однако при доступе по индексу, необходимо пробежаться по всей цепочке, что в свлучае большого количества записей увеличивает время доступа.
Добавление и удаление элементов происводится заменой ссылок.

Особенности: 

- хранит не уникальные элементы;
- вывод значений упорядочен по вводу.

!!! С LinkedList случай особый. Вроде бы лучшего аналога связного списка нет и ходят легенды, что он на самом деле полезен. В действительности ситуаций, когда LinkedList лучше, чем ArrayList, в реальной жизни исключительно мало. До Java-8 LinkedList ещё мог пригодиться, если вы часто удаляете элементы, идущие не последовательно, по какому-то условию. В Java-8 для этих целей появился List.removeIf, который в ArrayList, конечно, реализован оптимальнее (элементы передвигаются только один раз). Если вам надо сделать много вставок в разные места (задача сама по себе экзотическая), скорее всего быстрее будет создать новый ArrayList, чем вставлять в существующий LinkedList. Ну и помните, что LinkedList кушает в несколько раз больше памяти, так как каждый элемент — это отдельный объект в куче со ссылками на следующий и предыдущий. LinkedList можно использовать только в качестве учебного примера.



Набор (set).

Интерфейс Set представляет собой набор уникальных значений, наследуется от Collection.

HashSet.

В отличие от List не допускает хранения дублей, если значение уже содержится, то дубль просто игнорируется.
При выводе порядок элементов не сохраняется и будет зависеть от значения хэш-функции для каждого элемента.

Особенности:

- хранит только уникальные значения;
- порядок элементов при выводе не зависит от порядка ввода, но и не рандом. Сортирует порядок по Hash каждого элемента. 

LinkedHashSet.

Также хранит только уникальные значения. В отличие от HashSet сохраняет порядок элементов.

TreeSet.

В отличие от первых двух, автоматически сортирует элементы по возрастанию. В случае строк, по алфавиту.

Хинт!

Нужен порядок элементов без дублей, используй LinkedHashSet. А если хочешь автоматически отсортированный вывод, смотри на TreeSet.



Карта (map).

Map представляет собой набор из пар элементов типа «ключ-значение».

HashMap. 

Особенности:

- порядок эелементов не сохраняется.
- при добавлении значения с тем же ключем, имеющееся значение перезатирается новым.

LinkedHashMap.

Особенности:

- сохраняет порядок элементов.

TreeMap.

Особенности:

- автоматически сортирует набор по ключам.

Хинт!

Если хочешь, что бы значение в Map не перезатиралось дублем, используй для добавления вместо put() putIfAbsent(), тогда добавление произойдет только если значение отсутсвует, а имеющееся не перезатрется.


Помимо рассмотренных наиболее популярных реализаций коллекций, существую еще три вида особенных реализаций.



Queue.

Queue - очередь, реализует принцип «first in – first out», т.е. «первым пришёл – первым ушёл». Добавление элементов в очередь делается методом add(), удаление – poll(), получение первого элемента без его удаления – peek().
Две самые простые реализации очереди – это LinkedList и PriorityQueue.
Для LinkedList сохраняется порядок ввода-вывода.
Для PriorityQueue автоматически сортируется по алфавиту, либо по возрастанию.


Stack.

Стек реализует принцип «last in – first out», т.е. «последним пришёл – первым вышел».
Добавление элементов осуществляется методом push(), а удаление методом pop().
Вывод элементов происходит в обратном порядке, начиная с последнего.
Считается устаревшим и не рекомендуется применять в новых проектах!!!


Deque.

Deque современная альтернатива Stack. 
Deque – это сокращение от «double ended queue» (двусторонняя очередь). Deque является расширением интерфейса очереди Queue.
Реализуется с помощью LinkedList и ArrayDeque. Добавление элементов осуществляется методом push(), а удаление методом pop().
ArrayDeque - порядок вывода наоборот, от последнего к первому.


Хинт!

Для простой реализации очереди Queue - выбери LinkedList. Нужно как-то сортировать элементы внутри очереди - PriorityQueue. В иных ситуациях используй - Deque.



SequencedCollection.

В Java 21 появилась новая группа интерфейсов коллекций, самым основным из которых является SequencedCollection.
Это расширение функционала Collection.

Доступны методы: 

- addFirst() и addLast() этот метод аналогичен add().
- getFirst() и getLast() возвращают первый или последний элемент, либо [] or NoSuchElementException если список пуст.
- reversed() инвертирует вывод элементов.
- removeFirst() и removeLast() для удаления, но если список пуст, получим исключение.

По производительности, операции чтения первого и последнего элемента, а также операции добавления и удаления в конец списка в реализациях ArrayList и LinkedList происходят мгновенно.
Добавление и удаление первого элемента в ArrayList гораздо медленее, чем в LinkedList.
Добавление addFirst() в LinkedList требует изменения ссылок (элементы остаются на месте, слева к ним присоединяется новый), это происходит мгновенно. Но в ArrayList нужно сначала сдвинуть все элементы массива вправо, 
чтобы появилось место для первого элемента. Хотя эта операция хорошо оптимизирована, для больших списков вызовет заметную задержку. То же с removeFirst() в ArrayList. Нужно сдвинуть все элементы влево, начиная со второго.
Поэтому, если работаешь с первым элементом, выбирай – LinkedList.



SequencedSet.

Частным случаем SequencedCollection является интерфейс SequencedSet. При этом он переопределяет унаследованный метод reversed(), возвращая не SequencedCollection, а сам SequencedSet.

Доступны теже методы для реализации LinkedHashSet:

- addFirst() и addLast() этот метод аналогичен add().
- getFirst() и getLast() возвращают первый или последний элемент, либо [] or NoSuchElementException если список пуст.
- reversed() инвертирует вывод элементов.
- removeFirst() и removeLast() для удаления, но если список пуст, получим исключение.

Однако для реализации TreeSet addFirst() и addLast() не доступны и вместо них добавляем элементы с помощью add() он сам разберется куда их добавить, первым или вторым - последним.
При этом удалить первый или последний элемент возможно, используюя removeLast() или removeFirst() соотвественно.


SequencedMap.

SequencedMap расширяет стандартный Map, добавляя в него методы для доступа и манипулирования первой и последней парой элементов Map.Entry
Доступны методы:

- putFirst();
- putLast() аналог put();
- reversed().

TreeMap.

TreeMap не поддерживает методы добавления первого и последнего элемента, т.к. ключи сортируются, добавление элементов делаем через put().

Доступны методы:

- pollFirstEntry() удалить первый;
- pollLastEntry() удалить последний;
- sequencedKeySet() получить упорядоченное множество ключей;
- sequencedValues() значений;
- sequencedEntrySet() множество;
- clear() очистить.




P.S. Полезные методы и оптимальные подходы:

List.subList

Про это уже писали, но стоит повторить. Наверно, самый недооценённый метод из Collections API. Бывает, что надо каким-то образом обработать часть списка (например, в алгоритмах семейства «разделяй и властвуй» или при распараллеливании задачи). Многие создают метод или класс, который завязывается на три параметра: List, from и to:

void processListPart(List<Item> list, int from, int to) {
    for(int idx = from; idx < to; idx++) {
        Item item = list.get(idx);
        ...
    }
}


Так незачем делать. Реализации алгоритма должно быть плевать, что она обрабатывает часть списка. Пишите:

void processList(List<Item> list) {
    for(Item item : list) {
        ...
    }
}


И вызывайте

processList(list.subList(from, to));


Даже если у вас всё в одном методе, удобнее воспользоваться расширенным циклом for, чем возиться с индексами:

for(Item item : list.subList(from, to)) {...}


Кроме того, subList — полнофункциональный список, он работает и на запись, внося соответствующие изменения в родительский список. Нужно удалить много элементов из середины списка? Ничего нет проще:

list.subList(from, to).clear();


У популярных реализаций вроде ArrayList это выполняется очень быстро.

Надо выяснить, начинается ли список с определённых элементов? И тут subList в руки!

List<String> prefix = Arrays.asList("a", "prefix", "values");
if(myList.size() >= prefix.size() && 
   myList.subList(0, prefix.size()).equals(prefix)) {...}


Надо добавить в один список все элементы другого списка за исключением первого? И тут subList придёт на помощь:

list1.addAll(list2.subList(1, list2.size()));


Не забывайте, что можно писать Arrays.asList(array).subList(from, to), поэтому вышесказанное применимо и для непримитивных массивов. Структурно менять вы их не сможете, но передавать кусок массива в метод, принимающий список для чтения — легко.

PriorityQueue

Если subList — самый недооценённый метод, то PriorityQueue — это, на мой взгляд, самый недооценённый класс. Многие сталкиваются с задачей отыскать, скажем, 10 минимальных значений большого несортированного списка. Чаще всего список сортируют и потом берут первые 10 значений. Если исходный список менять нельзя, придётся его ещё скопировать для сортировки. А ведь очередь с приоритетом легко справится с этой задачей:

public static <T extends Comparable<T>> List<T> leastN(Collection<T> input, int n) {
    assert n > 0;
    PriorityQueue<T> pq = new PriorityQueue<>(Collections.reverseOrder());
    for (T t : input) {
        if (pq.size() < n) {
            pq.add(t);
        } else if (pq.peek().compareTo(t) > 0) {
            pq.poll();
            pq.add(t);
        }
    }
    List<T> list = new ArrayList<>(pq);
    Collections.sort(list);
    return list;
}



Такой код в зависимости от данных может работать гораздо быстрее, чем сортировка. Например, для n = 10 и случайно заполненного списка из миллиона элементов очередь с приоритетом почти в сто раз обгоняет подход с сортировкой. При этом дополнительной памяти требуется O(n) и входные элементы можно обрабатывать в потоковом режиме (например, выбрать 10 наименьших чисел из входного файла).

Вообще людям свойственно изучить пару-тройку структур данных и пользоваться ими везде. Не ленитесь, познакомьтесь с разными структурами.

EnumSet и EnumMap

До сих пор встречается код, где значения типа enum используют в качестве ключей в HashSet и HashMap. Хотя это работает, но оно неоправданно расточительно. Существующие специальные классы EnumSet и EnumMap значительно производительнее. Так если в enum не больше 64 разных значений, EnumSet хранит всё в одном поле типа long в битовой маске. EnumMap содержит все значения в обычном массиве той же длины, сколько элементов в enum, а ключи не хранит вовсе. Так как у каждого значения в enum есть порядковый номер ordinal(), можно легко перейти от enum-ключа к элементу массива. Также никогда не нужно менять размер массива.

Set.add(E) и Set.remove(E) возвращают булево значение

Часто вижу подобный код:

if(!set.contains(item)) {
    set.add(item);
    // do something
} else {
    // do something else
}


Не надо забывать, что операция добавления в Set возвращает true, если добавление успешно (то есть элемента не было) и false, если такой элемент уже был. Незачем усложнять код и два раза пробивать элемент по хэш-таблице или двоичному дереву, ведь можно написать:

if(set.add(item)) {
    // do something
} else {
    // do something else
}


Аналогично с удалением. Цепочка if(set.contains(item)) { set.remove(item); ... } заменяется на if(set.remove(item)) { ... }.

Map.put(K, V), Map.remove(K), List.set(idx, E), List.remove(idx) возвращают предыдущий элемент

Из той же оперы ситуация. Методы, изменяющие или удаляющие элемент в коллекции возвращают предыдущее значение, и этим надо пользоваться. Не надо писать, например, так:

Item item = myMap.get(key);
myMap.put(key, newItem);


Написать просто Item item = myMap.put(key, newItem);. Хотите поменять местами две записи в Map с ключами key1, key2? Временная переменная не нужна:

myMap.put(key1, myMap.put(key2, myMap.get(key1)));



Map.keySet() и Map.values()

Многие почему-то забывают, что Map.keySet() и Map.values() возвращают отображения исходного Map, которые позволяют удалять элементы (если Map модифицируемый). Надо оставить в Map только записи с определёнными значениями (и любыми ключами)? Пожалуйста:

myMap.values().retainAll(toRetain);


Также работает removeAll, а с Java-8 ещё и removeIf:

// Сгруппируем сотрудников по названиям подразделений
Map<String, List<Employee>> perDepartment = employees.stream().collect(groupingBy(Employee::getDepartmentName, HashMap::new, toList()));
// Оставим только крупные подразделения с числом сотрудников от 10
perDepartment.values().removeIf(list -> list.size() < 10);



Arrays.asList может быть ключом

Бывает, что вам нужно сформировать Map или Set, используя кортеж значений. Например, у вас есть PoJo-объекты Item, у которых имеются поля name, type, version. У них уже написан equals и hashCode, их можно складывать в HashSet, всё нормально. Но вы хотите выбрать из коллекции уникальные объекты только по полям name и type, игнорируя version. Менять существующие equals и hashCode нельзя. В таких ситуациях люди часто создают отдельный класс только с полями name и type и используют его в качестве ключа. Однако для одноразовой операции проще использовать Arrays.asList():

Map<List<Object>, Item> map = new HashMap<>();
for(Item item : items) {
	map.put(Arrays.asList(item.name, item.type), item);
}
Collection<Item> unique = map.values();


Arrays.asList() создаёт список из нужного числа элементов и у него как раз подходящие реализации equals и hashCode: никакой boilerplate не нужен. Так можно создать ключ любой длины, причём корректно обработаются null-значения и примитивы (брагодаря боксингу). Не сработает только, если вы хотите в составе ключа иметь массив.

Collections.min/max

Удивительно, насколько часто можно встретить написанный вручную код, который находит максимальный или минимальный элемент чего-то по какому-нибудь критерию. Казалось бы, такая тривиальная задача должна быть давно решена. На самом деле она и так давно решена: есть методы Collections.min и Collections.max. Раньше было не очень удобно писать компараторы, но в Java-8 всё стало легче.

К примеру, вам нужно найти ключ в Map, соответствующий максимальному значению. Пишите так:

maxKey = Collections.max(map.entrySet(), Map.Entry.comparingByValue()).getKey();


Можно и через Stream API, но Collections.max() несколько быстрее. Если вы не можете использовать Java-8 и компараторы вроде Entry.comparingByValue() вам недоступны, их нетрудно написать.

Stack, Vector, Hashtable, LinkedList

Просто не используйте эти классы. Пользы от них никакой нет. Вместо Stack пользуйтесь ArrayDeque, вместо Vector — ArrayList, вместо Hashtable — HashMap. Если вам нужна потокобезопасность, они вам всё равно не помогут. Возможно, в девятке их всё-таки пометят @Deprecated (смотрите JEP 277).

С LinkedList случай особый. Вроде бы лучшего аналога связного списка нет и ходят легенды, что он на самом деле полезен. В действительности ситуаций, когда LinkedList лучше, чем ArrayList, в реальной жизни исключительно мало. До Java-8 LinkedList ещё мог пригодиться, если вы часто удаляете элементы, идущие не последовательно, по какому-то условию. В Java-8 для этих целей появился List.removeIf, который в ArrayList, конечно, реализован оптимальнее (элементы передвигаются только один раз). Если вам надо сделать много вставок в разные места (задача сама по себе экзотическая), скорее всего быстрее будет создать новый ArrayList, чем вставлять в существующий LinkedList. Ну и помните, что LinkedList кушает в несколько раз больше памяти, так как каждый элемент — это отдельный объект в куче со ссылками на следующий и предыдущий. LinkedList можно использовать только в качестве учебного примера.
